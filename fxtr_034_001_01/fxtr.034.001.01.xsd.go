// Code generated by download. DO NOT EDIT.

package iso20022_fxtr_034_001_01

import (
	"bytes"
	"encoding/xml"
	"time"
)

type ActiveCurrencyAnd13DecimalAmount struct {
	Value float64            `xml:",chardata"`
	Ccy   ActiveCurrencyCode `xml:"Ccy,attr"`
}

type ActiveCurrencyAndAmount struct {
	Value float64            `xml:",chardata"`
	Ccy   ActiveCurrencyCode `xml:"Ccy,attr"`
}

// Must match the pattern [A-Z]{3,3}
type ActiveCurrencyCode string

type AgreedRate3 struct {
	XchgRate float64            `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 XchgRate"`
	UnitCcy  ActiveCurrencyCode `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 UnitCcy,omitempty"`
	QtdCcy   ActiveCurrencyCode `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 QtdCcy,omitempty"`
}

type AlternateIdentification1 struct {
	Id    Max35Text                   `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Id"`
	IdSrc IdentificationSource1Choice `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 IdSrc"`
}

// Must match the pattern [A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}
type AnyBICIdentifier string

// May be no more than 35 items long
type BloombergIdentifier string

// May be one of GRNE, NEMA, NENE
type ClearingMethod1Code string

// May be one of CONF, CNRR, STAT
type ConfirmationRequest1Code string

// May be no more than 35 items long
type ConsolidatedTapeAssociationIdentifier string

// Must match the pattern [A-Z]{2,2}
type CountryCode string

type CurrencyAndAmount struct {
	Value float64      `xml:",chardata"`
	Ccy   CurrencyCode `xml:"Ccy,attr"`
}

// Must match the pattern [A-Z]{3,3}
type CurrencyCode string

type DateAndDateTimeChoice struct {
	Dt   ISODate     `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Dt,omitempty"`
	DtTm ISODateTime `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 DtTm,omitempty"`
}

type DateFormat18Choice struct {
	Dt         DateAndDateTimeChoice `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Dt,omitempty"`
	NotSpcfdDt DateType8Code         `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 NotSpcfdDt,omitempty"`
}

// May be one of UKWN, ONGO
type DateType8Code string

type Document struct {
	FXTradConfReq ForeignExchangeTradeConfirmationRequestV01 `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 FXTradConfReq"`
}

// May be no more than 12 items long
type EuroclearClearstreamIdentifier string

type ForeignExchangeTradeConfirmationRequestV01 struct {
	Hdr         Header23                 `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Hdr"`
	ReqId       MessageIdentification1   `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 ReqId"`
	TradDtl     Trade2                   `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 TradDtl"`
	ConfTp      ConfirmationRequest1Code `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 ConfTp"`
	QryPrd      Period4                  `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 QryPrd"`
	QryStartNb  Max35NumericText         `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 QryStartNb"`
	QryTradSts  QueryTradeStatus1Code    `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 QryTradSts"`
	SplmtryData []SupplementaryData1     `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 SplmtryData,omitempty"`
}

type GenericIdentification32 struct {
	Id     Max35Text      `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Id"`
	Tp     PartyType3Code `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Tp,omitempty"`
	Issr   PartyType4Code `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Issr,omitempty"`
	ShrtNm Max35Text      `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 ShrtNm,omitempty"`
}

type Header23 struct {
	FrmtVrsn Max6Text                `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 FrmtVrsn"`
	XchgId   Max3NumericText         `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 XchgId"`
	InitgPty GenericIdentification32 `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 InitgPty"`
	RcptPty  GenericIdentification32 `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 RcptPty,omitempty"`
	MsgSeqNb float64                 `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 MsgSeqNb"`
	CreDtTm  ISODateTime             `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 CreDtTm"`
}

// Must match the pattern [A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}
type ISINOct2015Identifier string

type ISODate time.Time

func (t *ISODate) UnmarshalText(text []byte) error {
	return (*xsdDate)(t).UnmarshalText(text)
}
func (t ISODate) MarshalText() ([]byte, error) {
	return xsdDate(t).MarshalText()
}

type ISODateTime time.Time

func (t *ISODateTime) UnmarshalText(text []byte) error {
	return (*xsdDateTime)(t).UnmarshalText(text)
}
func (t ISODateTime) MarshalText() ([]byte, error) {
	return xsdDateTime(t).MarshalText()
}

type IdentificationSource1Choice struct {
	Dmst  CountryCode `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Dmst,omitempty"`
	Prtry Max35Text   `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Prtry,omitempty"`
}

// May be one of CDCO, CFET, RICC, USDE
type IdentificationType2Code string

type InstrumentLeg6 struct {
	LegSd                    Side1Code                        `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegSd"`
	LegSttlmTp               SettlementDateCode               `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegSttlmTp"`
	LegSttlmDt               ISODateTime                      `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegSttlmDt"`
	LegLastPric              ActiveCurrencyAnd13DecimalAmount `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegLastPric"`
	LegSttlmCcy              CurrencyCode                     `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegSttlmCcy"`
	LegOrdrQty               CurrencyAndAmount                `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegOrdrQty"`
	LegFwdPts                float64                          `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegFwdPts"`
	LegClctdCtrPtyCcyLastQty CurrencyAndAmount                `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegClctdCtrPtyCcyLastQty"`
	LegRskAmt                ActiveCurrencyAndAmount          `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegRskAmt"`
	LegValtnRate             AgreedRate3                      `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegValtnRate"`
	LegValDt                 ISODate                          `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegValDt"`
	LegCcy                   CurrencyCode                     `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegCcy"`
	LegSymb                  Max35Text                        `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegSymb"`
	LegSctyId                SecurityIdentification18         `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LegSctyId"`
}

// May be no more than 350 items long
type Max350Text string

// Must match the pattern [0-9]{1,35}
type Max35NumericText string

// May be no more than 35 items long
type Max35Text string

// Must match the pattern [0-9]{1,3}
type Max3NumericText string

// May be no more than 6 items long
type Max6Text string

// May be no more than 70 items long
type Max70Text string

type MessageIdentification1 struct {
	Id      Max35Text   `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Id"`
	CreDtTm ISODateTime `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 CreDtTm"`
}

// May be one of OPOI, MERC, ACCP, ITAG, ACQR, CISS, DLIS
type PartyType3Code string

// May be one of MERC, ACCP, ITAG, ACQR, CISS, TAXH
type PartyType4Code string

type Period4 struct {
	StartDt DateFormat18Choice `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 StartDt"`
	EndDt   DateFormat18Choice `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 EndDt"`
}

// May be one of QAST, QCTR, QCIR, QETR, QNTR, QRTR
type QueryTradeStatus1Code string

// May be no more than 35 items long
type RICIdentifier string

type SecurityIdentification18 struct {
	SctyIdSrc IdentificationType2Code `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 SctyIdSrc"`
	SctyId    Max35Text               `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 SctyId"`
}

type SecurityIdentification22Choice struct {
	ISIN     ISINOct2015Identifier                 `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 ISIN,omitempty"`
	AltrnId  AlternateIdentification1              `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 AltrnId,omitempty"`
	RIC      RICIdentifier                         `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 RIC,omitempty"`
	TckrSymb TickerIdentifier                      `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 TckrSymb,omitempty"`
	Blmbrg   BloombergIdentifier                   `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Blmbrg,omitempty"`
	CTA      ConsolidatedTapeAssociationIdentifier `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 CTA,omitempty"`
	Cmon     EuroclearClearstreamIdentifier        `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Cmon,omitempty"`
}

// May be one of REGU, CASH, NXTD, TONE, TTWO, TTRE, TFOR, TFIV, SELL, FUTU, ASAP, ENDC, WHIF, WDIS, WHID, TBAT, MONT, CLEA, SAVE, WISS
type SettlementDateCode string

// May be one of BUYI, SELL, TWOS, BUMI, SEPL, SESH, SSEX, CROS, CRSH, CSHE, DEFI, OPPO, UNDI
type Side1Code string

type SupplementaryData1 struct {
	PlcAndNm Max350Text                 `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 PlcAndNm,omitempty"`
	Envlp    SupplementaryDataEnvelope1 `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Envlp"`
}

type SupplementaryDataEnvelope1 struct {
	Item string `xml:",any"`
}

// May be no more than 35 items long
type TickerIdentifier string

type Trade2 struct {
	TradId         Max35Text                        `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 TradId"`
	TradDt         ISODate                          `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 TradDt"`
	FXTradPdct     UnderlyingProductIdentifier1Code `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 FXTradPdct"`
	TradgCcy       CurrencyCode                     `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 TradgCcy,omitempty"`
	SttlmCcy       CurrencyCode                     `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 SttlmCcy,omitempty"`
	TradgMtd       TradingMethodType1Code           `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 TradgMtd,omitempty"`
	TradgMd        TradingModeType1Code             `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 TradgMd"`
	ClrMtd         ClearingMethod1Code              `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 ClrMtd"`
	Symb           Max35Text                        `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 Symb,omitempty"`
	PlcOfConf      AnyBICIdentifier                 `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 PlcOfConf,omitempty"`
	FXDtls         Trade3                           `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 FXDtls,omitempty"`
	SwpLeg         []InstrumentLeg6                 `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 SwpLeg,omitempty"`
	PdctId         SecurityIdentification22Choice   `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 PdctId,omitempty"`
	AssoctdTradRef []Max70Text                      `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 AssoctdTradRef,omitempty"`
}

type Trade3 struct {
	ExctnPric             ActiveCurrencyAnd13DecimalAmount `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 ExctnPric"`
	LastQty               CurrencyAndAmount                `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 LastQty"`
	SttlmTp               SettlementDateCode               `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 SttlmTp"`
	SttlmDt               ISODate                          `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 SttlmDt"`
	ValtnRate             AgreedRate3                      `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 ValtnRate"`
	FwdPts                float64                          `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 FwdPts,omitempty"`
	ClctdCtrPtyCcyLastQty CurrencyAndAmount                `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 ClctdCtrPtyCcyLastQty"`
	ValDt                 ISODate                          `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 ValDt"`
	RskAmt                ActiveCurrencyAndAmount          `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 RskAmt"`
	SctyId                SecurityIdentification18         `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 SctyId"`
	FxgCcy                CurrencyCode                     `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 FxgCcy,omitempty"`
	FxgDt                 ISODate                          `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 FxgDt,omitempty"`
	OptnInd               bool                             `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 OptnInd,omitempty"`
	DltaInd               bool                             `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 DltaInd,omitempty"`
	AssoctdTradRef        []Max70Text                      `xml:"urn:iso:std:iso:20022:tech:xsd:fxtr.034.001.01 AssoctdTradRef,omitempty"`
}

// May be one of BITR, CERB, CUMA, LIOR, NETR, ONCT, QUAU, TEAU, ANCL
type TradingMethodType1Code string

// May be one of QUDR, ORDR, NETR, AUCT, MARC, BILA, ANON
type TradingModeType1Code string

// May be one of FORW, NDFO, SPOT, SWAP
type UnderlyingProductIdentifier1Code string

type xsdDate time.Time

func (t *xsdDate) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02")
}
func (t xsdDate) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02")
}
func (t xsdDate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDate) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) {
	s := string(bytes.TrimSpace(text))
	*t, err = time.Parse(format, s)
	if _, ok := err.(*time.ParseError); ok {
		*t, err = time.Parse(format+"Z07:00", s)
	}
	return err
}
func _marshalTime(t time.Time, format string) ([]byte, error) {
	return []byte(t.Format(format + "Z07:00")), nil
}

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
