// Code generated by download. DO NOT EDIT.

package iso20022_auth_043_001_01

import (
	"bytes"
	"encoding/xml"
	"time"
)

// May be one of WIBO, TREA, TIBO, TLBO, SWAP, STBO, PRBO, PFAN, NIBO, MAAA, MOSP, LIBO, LIBI, JIBA, ISDA, GCFR, FUSW, EUCH, EUUS, EURI, EONS, EONA, CIBO, CDOR, BUBO, BBSW
type BenchmarkCurveName2Code string

// Must match the pattern [A-Z]{2,2}
type CountryCode string

type Document struct {
	FinInstrmRptgRefDataIndxRpt FinancialInstrumentReportingReferenceDataIndexReportV01 `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 FinInstrmRptgRefDataIndxRpt"`
}

type FinancialInstrument46Choice struct {
	ISIN ISINOct2015Identifier   `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 ISIN,omitempty"`
	Indx BenchmarkCurveName2Code `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 Indx,omitempty"`
}

type FinancialInstrumentReportingReferenceDataIndexReportV01 struct {
	RptHdr      SecuritiesMarketReportHeader1 `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 RptHdr"`
	IndxData    []SecuritiesIndexReport1      `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 IndxData"`
	SplmtryData []SupplementaryData1          `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 SplmtryData,omitempty"`
}

// Must match the pattern [A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}
type ISINOct2015Identifier string

type ISODate time.Time

func (t *ISODate) UnmarshalText(text []byte) error {
	return (*xsdDate)(t).UnmarshalText(text)
}
func (t ISODate) MarshalText() ([]byte, error) {
	return xsdDate(t).MarshalText()
}

type ISODateTime time.Time

func (t *ISODateTime) UnmarshalText(text []byte) error {
	return (*xsdDateTime)(t).UnmarshalText(text)
}
func (t ISODateTime) MarshalText() ([]byte, error) {
	return xsdDateTime(t).MarshalText()
}

// Must match the pattern [A-Z0-9]{4,4}
type MICIdentifier string

// May be no more than 350 items long
type Max350Text string

// May be no more than 35 items long
type Max35Text string

// May be no more than 50 items long
type Max50Text string

type Period2 struct {
	FrDt ISODate `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 FrDt"`
	ToDt ISODate `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 ToDt"`
}

type Period4Choice struct {
	Dt       ISODate `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 Dt,omitempty"`
	FrDt     ISODate `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 FrDt,omitempty"`
	ToDt     ISODate `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 ToDt,omitempty"`
	FrDtToDt Period2 `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 FrDtToDt,omitempty"`
}

type SecuritiesIndexReport1 struct {
	TechRcrdId Max35Text                   `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 TechRcrdId,omitempty"`
	RqstngNtty CountryCode                 `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 RqstngNtty,omitempty"`
	Indx       FinancialInstrument46Choice `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 Indx"`
	VldtyPrd   Period4Choice               `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 VldtyPrd,omitempty"`
}

type SecuritiesMarketReportHeader1 struct {
	RptgNtty     TradingVenueIdentification1Choice `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 RptgNtty"`
	RptgPrd      Period4Choice                     `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 RptgPrd"`
	SubmissnDtTm ISODateTime                       `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 SubmissnDtTm,omitempty"`
}

type SupplementaryData1 struct {
	PlcAndNm Max350Text                 `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 PlcAndNm,omitempty"`
	Envlp    SupplementaryDataEnvelope1 `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 Envlp"`
}

type SupplementaryDataEnvelope1 struct {
	Item string `xml:",any"`
}

// May be one of APPA, CTPS
type TradingVenue2Code string

type TradingVenueIdentification1Choice struct {
	MktIdCd          MICIdentifier               `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 MktIdCd,omitempty"`
	NtlCmptntAuthrty CountryCode                 `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 NtlCmptntAuthrty,omitempty"`
	Othr             TradingVenueIdentification2 `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 Othr,omitempty"`
}

type TradingVenueIdentification2 struct {
	Id Max50Text         `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 Id"`
	Tp TradingVenue2Code `xml:"urn:iso:std:iso:20022:tech:xsd:auth.043.001.01 Tp"`
}

type xsdDate time.Time

func (t *xsdDate) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02")
}
func (t xsdDate) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02")
}
func (t xsdDate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDate) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) {
	s := string(bytes.TrimSpace(text))
	*t, err = time.Parse(format, s)
	if _, ok := err.(*time.ParseError); ok {
		*t, err = time.Parse(format+"Z07:00", s)
	}
	return err
}
func _marshalTime(t time.Time, format string) ([]byte, error) {
	return []byte(t.Format(format + "Z07:00")), nil
}

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
