// Code generated by download. DO NOT EDIT.

package iso20022_colr_011_001_04

import (
	"bytes"
	"encoding/xml"
	"time"
)

type ActiveCurrencyAndAmount struct {
	Value float64            `xml:",chardata"`
	Ccy   ActiveCurrencyCode `xml:"Ccy,attr"`
}

// Must match the pattern [A-Z]{3,3}
type ActiveCurrencyCode string

type Agreement4 struct {
	AgrmtDtls  Max140Text                `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 AgrmtDtls"`
	AgrmtId    Max140Text                `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 AgrmtId,omitempty"`
	AgrmtDt    ISODate                   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 AgrmtDt"`
	BaseCcy    ActiveCurrencyCode        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 BaseCcy"`
	AgrmtFrmwk AgreementFramework1Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 AgrmtFrmwk,omitempty"`
}

type AgreementFramework1Choice struct {
	AgrmtFrmwk AgreementFramework1Code `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 AgrmtFrmwk,omitempty"`
	PrtryId    GenericIdentification30 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 PrtryId,omitempty"`
}

// May be one of FBAA, BBAA, DERV, ISDA, NONR
type AgreementFramework1Code string

// Must match the pattern [A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}
type AnyBICIdentifier string

type CollateralAccount2 struct {
	Id Max35Text                                  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Id"`
	Tp CollateralAccountIdentificationType2Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Tp,omitempty"`
	Nm Max70Text                                  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Nm,omitempty"`
}

type CollateralAccountIdentificationType2Choice struct {
	Tp    CollateralAccountType1Code `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Tp,omitempty"`
	Prtry GenericIdentification36    `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Prtry,omitempty"`
}

// May be one of HOUS, CLIE, LIPR, MGIN, DFLT
type CollateralAccountType1Code string

type CollateralSubstitutionResponse1 struct {
	CollSbstitnReqId Max35Text               `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 CollSbstitnReqId"`
	AccptdAmt        ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 AccptdAmt,omitempty"`
}

type CollateralSubstitutionResponse2 struct {
	CollSbstitnReqId Max35Text               `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 CollSbstitnReqId"`
	RjctdAmt         ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 RjctdAmt"`
	RjctnRsn         RejectionReasonV021Code `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 RjctnRsn"`
	RjctnRsnInf      Max140Text              `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 RjctnRsnInf,omitempty"`
}

type CollateralSubstitutionResponseV04 struct {
	TxId        Max35Text             `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 TxId"`
	Oblgtn      Obligation4           `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Oblgtn"`
	Agrmt       Agreement4            `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Agrmt,omitempty"`
	SbstitnRspn SubstitutionResponse1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 SbstitnRspn"`
	SplmtryData []SupplementaryData1  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 SplmtryData,omitempty"`
}

// Must match the pattern [A-Z]{2,2}
type CountryCode string

type DateAndDateTimeChoice struct {
	Dt   ISODate     `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Dt,omitempty"`
	DtTm ISODateTime `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 DtTm,omitempty"`
}

type Document struct {
	CollSbstitnRspn CollateralSubstitutionResponseV04 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 CollSbstitnRspn"`
}

// Must match the pattern [a-zA-Z0-9]{4}
type Exact4AlphaNumericText string

// May be one of BFWD, PAYM, CCPC, COMM, CRDS, CRTL, CRSP, CCIR, CRPR, EQUI, EQPT, EQUS, EXTD, EXPT, FIXI, FORX, FORW, FUTR, OPTN, LIQU, OTCD, REPO, RVPO, SLOA, SBSC, SCRP, SLEB, SHSL, SCIR, SCIE, SWPT, TBAS, TRBD, TRCP
type ExposureType5Code string

type GenericIdentification30 struct {
	Id      Exact4AlphaNumericText `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Id"`
	Issr    Max35Text              `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Issr"`
	SchmeNm Max35Text              `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 SchmeNm,omitempty"`
}

type GenericIdentification36 struct {
	Id      Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Id"`
	Issr    Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Issr"`
	SchmeNm Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 SchmeNm,omitempty"`
}

type ISODate time.Time

func (t *ISODate) UnmarshalText(text []byte) error {
	return (*xsdDate)(t).UnmarshalText(text)
}
func (t ISODate) MarshalText() ([]byte, error) {
	return xsdDate(t).MarshalText()
}

type ISODateTime time.Time

func (t *ISODateTime) UnmarshalText(text []byte) error {
	return (*xsdDateTime)(t).UnmarshalText(text)
}
func (t ISODateTime) MarshalText() ([]byte, error) {
	return xsdDateTime(t).MarshalText()
}

// May be no more than 140 items long
type Max140Text string

// May be no more than 16 items long
type Max16Text string

// May be no more than 350 items long
type Max350Text string

// May be no more than 35 items long
type Max35Text string

// May be no more than 70 items long
type Max70Text string

type NameAndAddress6 struct {
	Nm  Max70Text      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Nm"`
	Adr PostalAddress2 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Adr"`
}

type Obligation4 struct {
	PtyA       PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 PtyA"`
	SvcgPtyA   PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 SvcgPtyA,omitempty"`
	PtyB       PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 PtyB"`
	SvcgPtyB   PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 SvcgPtyB,omitempty"`
	CollAcctId CollateralAccount2           `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 CollAcctId,omitempty"`
	XpsrTp     ExposureType5Code            `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 XpsrTp,omitempty"`
	ValtnDt    DateAndDateTimeChoice        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 ValtnDt"`
}

type PartyIdentification100Choice struct {
	AnyBIC   AnyBICIdentifier        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 AnyBIC,omitempty"`
	PrtryId  GenericIdentification36 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 PrtryId,omitempty"`
	NmAndAdr NameAndAddress6         `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 NmAndAdr,omitempty"`
}

type PostalAddress2 struct {
	StrtNm      Max70Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 StrtNm,omitempty"`
	PstCdId     Max16Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 PstCdId"`
	TwnNm       Max35Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 TwnNm"`
	CtrySubDvsn Max35Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 CtrySubDvsn,omitempty"`
	Ctry        CountryCode `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Ctry"`
}

// May be one of DSEC, EVNM, UKWN, ICOL, CONL, ELIG, INID, OTHR
type RejectionReasonV021Code string

// May be one of REJT, PACK
type Status4Code string

type SubstitutionResponse1 struct {
	RspnTp                 Status4Code                     `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 RspnTp"`
	CollSbstitnAccptncDtls CollateralSubstitutionResponse1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 CollSbstitnAccptncDtls,omitempty"`
	CollSbstitnRjctnDtls   CollateralSubstitutionResponse2 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 CollSbstitnRjctnDtls,omitempty"`
}

type SupplementaryData1 struct {
	PlcAndNm Max350Text                 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 PlcAndNm,omitempty"`
	Envlp    SupplementaryDataEnvelope1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.011.001.04 Envlp"`
}

type SupplementaryDataEnvelope1 struct {
	Item string `xml:",any"`
}

type xsdDate time.Time

func (t *xsdDate) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02")
}
func (t xsdDate) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02")
}
func (t xsdDate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDate) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) {
	s := string(bytes.TrimSpace(text))
	*t, err = time.Parse(format, s)
	if _, ok := err.(*time.ParseError); ok {
		*t, err = time.Parse(format+"Z07:00", s)
	}
	return err
}
func _marshalTime(t time.Time, format string) ([]byte, error) {
	return []byte(t.Format(format + "Z07:00")), nil
}

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
