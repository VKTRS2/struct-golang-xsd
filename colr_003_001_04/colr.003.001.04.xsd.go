// Code generated by download. DO NOT EDIT.

package iso20022_colr_003_001_04

import (
	"bytes"
	"encoding/xml"
	"time"
)

type ActiveCurrencyAndAmount struct {
	Value float64            `xml:",chardata"`
	Ccy   ActiveCurrencyCode `xml:"Ccy,attr"`
}

// Must match the pattern [A-Z]{3,3}
type ActiveCurrencyCode string

type AggregatedIndependentAmount1 struct {
	Trad      IndependentAmount1   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Trad,omitempty"`
	ValAtRsk  IndependentAmount1   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 ValAtRsk,omitempty"`
	NetOpnPos IndependentAmount1   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 NetOpnPos,omitempty"`
	OthrAmt   []IndependentAmount2 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 OthrAmt,omitempty"`
}

type Agreement4 struct {
	AgrmtDtls  Max140Text                `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 AgrmtDtls"`
	AgrmtId    Max140Text                `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 AgrmtId,omitempty"`
	AgrmtDt    ISODate                   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 AgrmtDt"`
	BaseCcy    ActiveCurrencyCode        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 BaseCcy"`
	AgrmtFrmwk AgreementFramework1Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 AgrmtFrmwk,omitempty"`
}

type AgreementFramework1Choice struct {
	AgrmtFrmwk AgreementFramework1Code `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 AgrmtFrmwk,omitempty"`
	PrtryId    GenericIdentification30 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 PrtryId,omitempty"`
}

// May be one of FBAA, BBAA, DERV, ISDA, NONR
type AgreementFramework1Code string

// Must match the pattern [A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}
type AnyBICIdentifier string

type Collateral1 struct {
	VartnMrgn       MarginCollateral1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 VartnMrgn"`
	SgrtdIndpdntAmt MarginCollateral1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SgrtdIndpdntAmt,omitempty"`
}

type CollateralAccount2 struct {
	Id Max35Text                                  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Id"`
	Tp CollateralAccountIdentificationType2Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Tp,omitempty"`
	Nm Max70Text                                  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Nm,omitempty"`
}

type CollateralAccountIdentificationType2Choice struct {
	Tp    CollateralAccountType1Code `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Tp,omitempty"`
	Prtry GenericIdentification36    `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Prtry,omitempty"`
}

// May be one of HOUS, CLIE, LIPR, MGIN, DFLT
type CollateralAccountType1Code string

type CollateralBalance1Choice struct {
	TtlColl         ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 TtlColl,omitempty"`
	CollDtls        Collateral1             `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 CollDtls,omitempty"`
	SgrtdIndpdntAmt MarginCollateral1       `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SgrtdIndpdntAmt,omitempty"`
}

type CollateralMovement9 struct {
	CollTp CollateralType1Code `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 CollTp"`
	Dt     ISODate             `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Dt,omitempty"`
}

// May be one of CASH, SECU, LCRE, OTHR
type CollateralType1Code string

// Must match the pattern [A-Z]{2,2}
type CountryCode string

type DateAndDateTimeChoice struct {
	Dt   ISODate     `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Dt,omitempty"`
	DtTm ISODateTime `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 DtTm,omitempty"`
}

type Document struct {
	MrgnCallReq MarginCallRequestV04 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnCallReq"`
}

// Must match the pattern [a-zA-Z0-9]{4}
type Exact4AlphaNumericText string

type ExpectedCollateral2 struct {
	VartnMrgn       ExpectedCollateralMovement2 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 VartnMrgn"`
	SgrtdIndpdntAmt ExpectedCollateralMovement2 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SgrtdIndpdntAmt,omitempty"`
}

type ExpectedCollateral2Choice struct {
	XpctdCollDtls   ExpectedCollateral2         `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 XpctdCollDtls,omitempty"`
	SgrtdIndpdntAmt ExpectedCollateralMovement2 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SgrtdIndpdntAmt,omitempty"`
}

type ExpectedCollateralMovement2 struct {
	Dlvry []CollateralMovement9 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Dlvry,omitempty"`
	Rtr   []CollateralMovement9 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Rtr,omitempty"`
}

// May be one of GROS, NET1
type ExposureConventionType1Code string

// May be one of BFWD, PAYM, CCPC, COMM, CRDS, CRTL, CRSP, CCIR, CRPR, EQUI, EQPT, EQUS, EXTD, EXPT, FIXI, FORX, FORW, FUTR, OPTN, LIQU, OTCD, REPO, RVPO, SLOA, SBSC, SCRP, SLEB, SHSL, SCIR, SCIE, SWPT, TBAS, TRBD, TRCP
type ExposureType5Code string

type GenericIdentification30 struct {
	Id      Exact4AlphaNumericText `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Id"`
	Issr    Max35Text              `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Issr"`
	SchmeNm Max35Text              `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SchmeNm,omitempty"`
}

type GenericIdentification36 struct {
	Id      Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Id"`
	Issr    Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Issr"`
	SchmeNm Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SchmeNm,omitempty"`
}

type ISODate time.Time

func (t *ISODate) UnmarshalText(text []byte) error {
	return (*xsdDate)(t).UnmarshalText(text)
}
func (t ISODate) MarshalText() ([]byte, error) {
	return xsdDate(t).MarshalText()
}

type ISODateTime time.Time

func (t *ISODateTime) UnmarshalText(text []byte) error {
	return (*xsdDateTime)(t).UnmarshalText(text)
}
func (t ISODateTime) MarshalText() ([]byte, error) {
	return xsdDateTime(t).MarshalText()
}

type IndependentAmount1 struct {
	Amt    ActiveCurrencyAndAmount              `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Amt"`
	Cnvntn IndependentAmountConventionType1Code `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Cnvntn"`
}

type IndependentAmount2 struct {
	Desc   Max140Text                           `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Desc,omitempty"`
	Amt    ActiveCurrencyAndAmount              `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Amt"`
	Cnvntn IndependentAmountConventionType1Code `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Cnvntn"`
}

// May be one of NBTR, NATR, SEGR
type IndependentAmountConventionType1Code string

type Margin1 struct {
	VartnMrgn           VariationMargin1                   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 VartnMrgn"`
	SgrtdIndpdntAmtMrgn SegregatedIndependentAmountMargin1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SgrtdIndpdntAmtMrgn,omitempty"`
}

type MarginCall1 struct {
	XpsdAmtPtyA    ActiveCurrencyAndAmount      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 XpsdAmtPtyA,omitempty"`
	XpsdAmtPtyB    ActiveCurrencyAndAmount      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 XpsdAmtPtyB,omitempty"`
	XpsrCnvntn     ExposureConventionType1Code  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 XpsrCnvntn,omitempty"`
	IndpdntAmtPtyA AggregatedIndependentAmount1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 IndpdntAmtPtyA,omitempty"`
	IndpdntAmtPtyB AggregatedIndependentAmount1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 IndpdntAmtPtyB,omitempty"`
	MrgnTerms      MarginTerms1Choice           `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnTerms,omitempty"`
	CollBal        CollateralBalance1Choice     `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 CollBal,omitempty"`
}

type MarginCall2 struct {
	CollAcctId       CollateralAccount2        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 CollAcctId,omitempty"`
	MrgnCallRslt     MarginCallResult3         `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnCallRslt"`
	MrgnDtlDueToA    MarginCall1               `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnDtlDueToA,omitempty"`
	MrgnDtlDueToB    MarginCall1               `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnDtlDueToB,omitempty"`
	RqrmntDtlsDueToA MarginRequirement1Choice  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 RqrmntDtlsDueToA,omitempty"`
	RqrmntDtlsDueToB MarginRequirement1Choice  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 RqrmntDtlsDueToB,omitempty"`
	XpctdCollDueToA  ExpectedCollateral2Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 XpctdCollDueToA,omitempty"`
	XpctdCollDueToB  ExpectedCollateral2Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 XpctdCollDueToB,omitempty"`
}

type MarginCallRequestV04 struct {
	TxId             Max35Text                 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 TxId"`
	Oblgtn           Obligation4               `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Oblgtn"`
	Agrmt            Agreement4                `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Agrmt,omitempty"`
	MrgnCallRslt     MarginCallResult3         `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnCallRslt"`
	MrgnDtlsDueToA   MarginCall1               `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnDtlsDueToA,omitempty"`
	MrgnDtlsDueToB   MarginCall1               `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnDtlsDueToB,omitempty"`
	RqrmntDtlsDueToA MarginRequirement1Choice  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 RqrmntDtlsDueToA,omitempty"`
	RqrmntDtlsDueToB MarginRequirement1Choice  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 RqrmntDtlsDueToB,omitempty"`
	XpctdCollDueToA  ExpectedCollateral2Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 XpctdCollDueToA,omitempty"`
	XpctdCollDueToB  ExpectedCollateral2Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 XpctdCollDueToB,omitempty"`
	MrgnCallDtls     []MarginCall2             `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnCallDtls,omitempty"`
	SplmtryData      []SupplementaryData1      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SplmtryData,omitempty"`
}

type MarginCallResult2 struct {
	VartnMrgnRslt   Result1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 VartnMrgnRslt"`
	SgrtdIndpdntAmt Result1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SgrtdIndpdntAmt,omitempty"`
}

type MarginCallResult2Choice struct {
	MrgnCallRsltDtls MarginCallResult2 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnCallRsltDtls,omitempty"`
	MrgnCallAmt      Result1           `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnCallAmt,omitempty"`
	SgrtdIndpdntAmt  Result1           `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SgrtdIndpdntAmt,omitempty"`
}

type MarginCallResult3 struct {
	DfltFndAmt   ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 DfltFndAmt,omitempty"`
	MrgnCallRslt MarginCallResult2Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnCallRslt"`
}

type MarginCollateral1 struct {
	HeldByPtyA    ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 HeldByPtyA,omitempty"`
	HeldByPtyB    ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 HeldByPtyB,omitempty"`
	PrrAgrdToPtyA ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 PrrAgrdToPtyA,omitempty"`
	PrrAgrdToPtyB ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 PrrAgrdToPtyB,omitempty"`
	InTrnstToPtyA ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 InTrnstToPtyA,omitempty"`
	InTrnstToPtyB ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 InTrnstToPtyB,omitempty"`
}

type MarginRequirement1 struct {
	DlvrMrgnAmt ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 DlvrMrgnAmt,omitempty"`
	RtrMrgnAmt  ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 RtrMrgnAmt,omitempty"`
}

type MarginRequirement1Choice struct {
	MrgnRqrmnt            Requirement1       `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnRqrmnt,omitempty"`
	SgrtdIndpdntAmtRqrmnt MarginRequirement1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SgrtdIndpdntAmtRqrmnt,omitempty"`
}

type MarginTerms1Choice struct {
	MrgnDtls            Margin1                            `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MrgnDtls,omitempty"`
	SgrtdIndpdntAmtMrgn SegregatedIndependentAmountMargin1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SgrtdIndpdntAmtMrgn,omitempty"`
}

// May be no more than 140 items long
type Max140Text string

// May be no more than 16 items long
type Max16Text string

// May be no more than 210 items long
type Max210Text string

// May be no more than 350 items long
type Max350Text string

// May be no more than 35 items long
type Max35Text string

// May be no more than 70 items long
type Max70Text string

type NameAndAddress6 struct {
	Nm  Max70Text      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Nm"`
	Adr PostalAddress2 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Adr"`
}

type Obligation4 struct {
	PtyA       PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 PtyA"`
	SvcgPtyA   PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SvcgPtyA,omitempty"`
	PtyB       PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 PtyB"`
	SvcgPtyB   PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SvcgPtyB,omitempty"`
	CollAcctId CollateralAccount2           `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 CollAcctId,omitempty"`
	XpsrTp     ExposureType5Code            `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 XpsrTp,omitempty"`
	ValtnDt    DateAndDateTimeChoice        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 ValtnDt"`
}

type PartyIdentification100Choice struct {
	AnyBIC   AnyBICIdentifier        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 AnyBIC,omitempty"`
	PrtryId  GenericIdentification36 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 PrtryId,omitempty"`
	NmAndAdr NameAndAddress6         `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 NmAndAdr,omitempty"`
}

type PostalAddress2 struct {
	StrtNm      Max70Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 StrtNm,omitempty"`
	PstCdId     Max16Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 PstCdId"`
	TwnNm       Max35Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 TwnNm"`
	CtrySubDvsn Max35Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 CtrySubDvsn,omitempty"`
	Ctry        CountryCode `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Ctry"`
}

type Requirement1 struct {
	VartnMrgnRqrmnt       MarginRequirement1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 VartnMrgnRqrmnt"`
	SgrtdIndpdntAmtRqrmnt MarginRequirement1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 SgrtdIndpdntAmtRqrmnt,omitempty"`
}

type Result1 struct {
	DueToPtyA ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 DueToPtyA,omitempty"`
	DueToPtyB ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 DueToPtyB,omitempty"`
	AddtlInf  Max210Text              `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 AddtlInf,omitempty"`
}

// May be one of DRDW, DRUP, NONE, CLSR
type RoundingMethod1Code string

type SegregatedIndependentAmountMargin1 struct {
	MinTrfAmt ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MinTrfAmt"`
	RndgAmt   ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 RndgAmt,omitempty"`
	RndgMtd   RoundingMethod1Code     `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 RndgMtd,omitempty"`
}

type SupplementaryData1 struct {
	PlcAndNm Max350Text                 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 PlcAndNm,omitempty"`
	Envlp    SupplementaryDataEnvelope1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 Envlp"`
}

type SupplementaryDataEnvelope1 struct {
	Item string `xml:",any"`
}

// May be one of SECU, UNSE
type ThresholdType1Code string

type VariationMargin1 struct {
	ThrshldAmt ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 ThrshldAmt"`
	ThrshldTp  ThresholdType1Code      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 ThrshldTp,omitempty"`
	MinTrfAmt  ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 MinTrfAmt"`
	RndgAmt    ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 RndgAmt"`
	RndgMtd    RoundingMethod1Code     `xml:"urn:iso:std:iso:20022:tech:xsd:colr.003.001.04 RndgMtd"`
}

type xsdDate time.Time

func (t *xsdDate) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02")
}
func (t xsdDate) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02")
}
func (t xsdDate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDate) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) {
	s := string(bytes.TrimSpace(text))
	*t, err = time.Parse(format, s)
	if _, ok := err.(*time.ParseError); ok {
		*t, err = time.Parse(format+"Z07:00", s)
	}
	return err
}
func _marshalTime(t time.Time, format string) ([]byte, error) {
	return []byte(t.Format(format + "Z07:00")), nil
}

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
